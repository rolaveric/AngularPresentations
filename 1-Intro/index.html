<!DOCTYPE html>
<html>
<head>
	<title>AngularJS Presentations - Introduction to AngularJS</title>
	<meta name="author" content="Jason Stone"/>
	<link href="style.css" rel="stylesheet" type="text/css"/>
</head>
<body>

<div class="reveal">

	<div class="slides">

		<section id="splash">
			<h2 class="splash-heading">Introduction to AngularJS</h2>
			<img class="splash-logo" src="../img/AngularJS-medium.png"/>
			<div class="author">
				<div class="author-name">Jason Stone</div>
				<div class="author-email">rolaveric@gmail.com</div>
				<div class="author-github">
					<a href="https://github.com/rolaveric/AngularPresentations" target="_blank">https://github.com/rolaveric/AngularPresentations</a>
				</div>
			</div>

			<aside class="notes">
				Welcome to [x].<br/>
				My name is [x] and I'm going to spend the next [x] minutes giving you an introduction to AngularJS.<br/>
				Please feel free to interrupt and ask questions.
			</aside>
		</section>

		<section id="what">
			<h2>What can AngularJS do for you?</h2>
			<div>
				<img class="shield" src="../img/AngularJS-Shield-medium.png"/>
				<span class="huge">?</span>
			</div>

			<aside class="notes">
				Breathe.
			</aside>
		</section>

		<section id="saves" class="step">
			<h3>Saves developers from Browser code that:</h3>
			<ul>
				<li>Constantly manipulates the DOM</li>
				<li>Is a nightmare to test</li>
				<li>Generally 'smells' bad</li>
			</ul>

			<aside class="notes">
				AngularJS provides the tools and, most importantly, the structure for writing good browser code.<br/>
				Code which isn't 80% DOM manipulation with jQuery selections and method chains.<br/>
				Code which is trivial to test and refactor<br/>
				And code which just generally feels 'good'.
			</aside>
		</section>

		<section id="how">
			<h1>How?</h1>

			<aside class="notes">
				OK, I've just made some pretty bold statements.  How does it do all that?
			</aside>
		</section>

		<section id="two-way">
			<section>
				<h2>2-way data binding</h2>
				<pre><code>
&lt;input ng-model="value"/&gt;
&lt;button ng-click="reverseValue()">reverse&lt;/button&gt;
&lt;span&gt;{{value}}&lt;/span&gt;
&lt;script type="text/javascript"&gt;
function MyCtrl($scope) {
	$scope.value = '';
	$scope.reverseValue = function () {
		$scope.value = $scope.value.split('').reverse().join();
	}
}
&lt;/script&gt;
				</code></pre>
				<iframe src="examples/dataBinding.html"></iframe>

				<aside class="notes">
					2-way data bindings.  Changes to my Javascript data model get reflected on the view, and in reverse too.<br/>
					Explain what's going on:
					<ul>
						<li>input bound to model 'value' on scope</li>
						<li>curly brackets creates a binding, which outputs scope 'value'</li>
						<li>controller provides a method for the scope, triggered on click</li>
					</ul>
				</aside>
			</section>

			<section>
				<h2>2-way data binding</h2>
				<img alt="http://docs.angularjs.org/guide/concepts" src="../img/concepts-runtime.png"/>
				<a href="http://docs.angularjs.org/guide/concepts">http://docs.angularjs.org/guide/concepts</a>

				<aside class="notes">
					How does it do that?<br/>
					Not going into too much detail.<br/>
					When an action is triggered through AngularJS, a $digest loop runs<br/>
					It dirty checks every binding for changes, rerunning until no changes are found.<br/>
					Be careful when binding to method calls - will get rerun multiple times.
				</aside>
			</section>
		</section>

		<section id="separation">
			<h2>Separation of concerns</h2>
			<dl>
				<dt>Templates</dt>
				<dd>Declare HTML + Directives</dd>
				<dt>Directives</dt>
				<dd>Manipulate the DOM</dd>
				<dt>Controllers</dt>
				<dd>Attach behaviour to the view scope</dd>
				<dt>Filters</dt>
				<dd>Transform data</dd>
				<dt>Services</dt>
				<dd>Do the work</dd>
			</dl>

			<aside class="notes">
				Templates declare the HTML.  They can easily be handed over to a designer.<br/>
				Directives perform DOM manipulation - Remember when I said AngularJS stops you constantly changing the DOM? That's because the work is encapsulated in directives.
				AngularJS provides a lot out of the box, but you can create your own.<br/>
				Controllers are the glue between your Javascript data model and the HTML view model.<br/>
				Filters are for transforming data, normally for output formatting. eg. Dates and currencies.<br/>
				Services are your work horses, which can be injected into controllers, filters, and directives as dependencies<br/>
				Which leads me to... (Dependency Injection)
			</aside>
		</section>

		<section id="injection">
			<h2>Dependency Injection</h2>
			<p>Doesn't matter where it comes from,<br/>just as long as it does what I say.</p>
			<pre><code>
function MyCtrl($scope, myDataStorage) {
	$scope.save = function (data) {
		myDataStorage.save(data);
	}
}

angular.module('mongoApp', []).value('myDataStorage', {
	save: function (data) { /* Do database stuff ... */ }
});

angular.module('testApp', []).value('myDataStorage', {
	save: function (data) {
		console.log('data saved: ' + angular.toJson(data);
	}
});
			</code></pre>

			<aside class="notes">
				Dependency Injection is what helps to keep all the pieces of our application nicely separated and loosely coupled.<br/>
				Trivial to switch out mock services for testing, or alternative IO services like databases.
			</aside>
		</section>

		<section id="zen-break">
			<h1>Zen Moment</h1>
			<div>Image source <a href="http://www.morguefile.com/">http://www.morguefile.com/</a></div>

			<aside class="notes">
				Hit 'b'<br/>
				Take a breather<br/>
				Answer questions
			</aside>
		</section>

		<section id="components">
			<h1>AngularJS Components</h1>

			<aside class="notes">
				Now I'm going to take you through the main components of AngularJS - the building blocks you'll use to create your application.
			</aside>
		</section>

		<section id="templates">
			<h2>View Templates</h2>
			<pre><code>&lt;div ng-app="MyApp"&gt;
	&lt;strong ng-init="title = 'My App'"&gt;{{title}}&lt;/strong&gt;&lt;br/&gt;
	&lt;label for="myInput"&gt;Item: &lt;/label&gt;
	&lt;input id="myInput" ng-model="itemInput"/&gt;
	&lt;button ng-click="items.push(itemInput)"&gt;Add&lt;/button&gt;
	&lt;ul ng-init="items = []"&gt;
		&lt;li ng-repeat="item in items"&gt;{{item}}&lt;/li&gt;
	&lt;/ul&gt;
&lt;/div&gt;
&lt;script type="text/javascript" src="../../lib/angular.min.js"&gt;&lt;/script&gt;
&lt;script type="text/javascript"&gt;
	angular.module('MyApp', []);
&lt;/script&gt;</code></pre>
			<iframe src="examples/htmlTemplates.html"></iframe>

			<aside class="notes">
				The best place to start is the view templates themselves - the HTML.<br/>
				The job of the view templates is simply to declare how the view should be structured and what it should do - though not how it should do it.<br/>
				In this case, there's a label for an input, and input for model 'itemInput', and a button which calls a method on 'push' - it really shouldn't get any more complicated than that.<br/>
				If it does, you need to be pushing that work back to the CSS or the Javascript to work out.<br/>
				These attributes you see starting with 'ng-' are directives - behaviour attached to specific elements or attributes.<br/>
				So when Angular compiles this template at run time, it will check for directives which handle an element called 'input' or an attribute called 'ng-model' and trigger them.
			</aside>
		</section>

		<section id="controllers">
			<section>
				<h2>Controllers and Scopes</h2>
				<p>Controllers attach data models to the scope.</p>
				<pre><code>&lt;div ng-app="MyApp" ng-controller="MyCtrl"&gt;
	&lt;div&gt;
		&lt;strong&gt;myValue: &lt;/strong&gt;
		&lt;input ng-model="myValue"/&gt;
		&lt;em&gt; {{myValue}}&lt;/em&gt;
	&lt;/div&gt;
	&lt;button ng-click="myMethod('myValue')"&gt;reset&lt;/button&gt;
	&lt;/div&gt;
&lt;script type="text/javascript"&gt;
function MyCtrl($scope) {
	$scope.myValue = 'My Value';
	$scope.myMethod = function (value) {
		$scope.myValue = value;
	};
}
&lt;/script&gt;</code></pre>
				<iframe src="examples/controllers1.html"></iframe>

				<aside class="notes">
					The job of controllers is simple - attach Javascript to the properties of the scope.<br/>
					Scopes are created by directives, in this case the 'ng-controller' directive which simply creates a scope and attaches a controller named 'MyCtrl' to it, and are attached to the element the scope was created on.<br/>
					Then any bindings created on the view for that element will use the properties of that scope.
				</aside>
			</section>

			<section>
				<h2>Controllers and Scopes</h2>
				<p>Scopes are attached to the view.</p>
				<pre><code>&lt;div ng-app="MyApp"&gt;
	&lt;div ng-controller="MyCtrl"&gt;
		&lt;div&gt;
			&lt;strong&gt;myValue: &lt;/strong&gt;
			&lt;input ng-model="myValue"/&gt;
			&lt;em&gt; {{myValue}}&lt;/em&gt;
		&lt;/div&gt;
		&lt;button ng-click="myMethod('myValue')"&gt;reset&lt;/button&gt;
	&lt;/div&gt;
	&lt;div ng-controller="MyCtrl"&gt;
		&lt;div&gt;
			&lt;strong&gt;myValue: &lt;/strong&gt;
			&lt;input ng-model="myValue"/&gt;
			&lt;em&gt; {{myValue}}&lt;/em&gt;
		&lt;/div&gt;
		&lt;button ng-click="myMethod('myValue')"&gt;reset&lt;/button&gt;
	&lt;/div&gt;
&lt;/div&gt;</code></pre>
				<iframe src="examples/controllers2.html"></iframe>

				<aside class="notes">
					You can use the same controller multiple times, with a different scope each time.<br/>
					So in this case, changes on one won't effect the other because the scopes are different.
				</aside>
			</section>

			<section>
				<h2>Controllers and Scopes</h2>
				<p>Scopes inherit from their parent scope.</p>
				<pre><code>&lt;div ng-app="MyApp"&gt;
	&lt;div ng-controller="MyCtrl"&gt;
		&lt;div&gt;
			&lt;strong&gt;myValue: &lt;/strong&gt;
			&lt;input ng-model="myValue"/&gt;
			&lt;em&gt; {{myValue}}&lt;/em&gt;
		&lt;/div&gt;
		&lt;div ng-controller="ChildCtrl"&gt;
			&lt;div&gt;
				&lt;strong&gt;myValue: &lt;/strong&gt;
				&lt;input ng-model="myValue"/&gt;
				&lt;em&gt; {{myValue}}&lt;/em&gt;
			&lt;/div&gt;
		&lt;/div&gt;
	&lt;/div&gt;
&lt;/div&gt;
&lt;script type="text/javascript"&gt;
	function ChildCtrl($scope) {}
&lt;/script&gt;</code></pre>
				<iframe src="examples/controllers3.html"></iframe>

				<aside class="notes">
					Scopes will generally inherit from a parent scope already attached to the view.<br/>
					The exception to this is what's called an 'isolate scope' which is used in making directives that don't interfere with the application they're called from.<br/>
					<em>Demo example</em><br/>
					Now notice how at first a change against the parent effects the child, but not in reverse.  And once I change the child's value, they're disconnected.<br/>
					Anyone have any idea why that is?
				</aside>
			</section>

			<section>
				<h2>Controllers and Scopes</h2>
				<p>The scope is NOT your data model.</p>
				<pre><code>&lt;div ng-app="MyApp"&gt;
	&lt;div ng-controller="MyCtrl"&gt;
		&lt;div&gt;
			&lt;strong&gt;myModel.myValue: &lt;/strong&gt;
			&lt;input ng-model="myModel.myValue"/&gt;
			&lt;em&gt; {{myModel.myValue}}&lt;/em&gt;
		&lt;/div&gt;
		&lt;div ng-controller="ChildCtrl"&gt;
			&lt;div&gt;
				&lt;strong&gt;myModel.myValue: &lt;/strong&gt;
				&lt;input ng-model="myModel.myValue"/&gt;
				&lt;em&gt; {{myModel.myValue}}&lt;/em&gt;
			&lt;/div&gt;
		&lt;/div&gt;
	&lt;/div&gt;
&lt;/div&gt;</code></pre>
				<iframe src="examples/controllers4.html"></iframe>

				<aside class="notes">
					A good rule of thumb for your 'ng-model' values is that they should always have a dot in them.<br/>
					That means you inherit a reference to the data object, and then alter a property of that object, rather than altering a property on the scope.<br/>
				</aside>
			</section>
		</section>

		<section id="filters">
			<section>
				<h2>Filters</h2>
				<p>Take an input and produce a single output</p>
				<pre><code>&lt;div ng-app=""&gt;
	&lt;div&gt;
		&lt;strong&gt;value: &lt;/strong&gt;
		&lt;input ng-model="value" value="My Value"/&gt;
		&lt;em&gt; {{value | uppercase}}&lt;/em&gt;
	&lt;/div&gt;
&lt;/div></code></pre>
				<iframe src="examples/filters1.html"></iframe>

				<aside class="notes">
					Filters are simply functions used for taking an input and outputting it in a different format.<br/>
					You can call them on your templates by using a pipe and then the name of the filter you want to use.
				</aside>
			</section>

			<section>
				<h2>Filters</h2>
				<p>Filters can take additional parameters:<br/>
					input:param1:param2:...</p>
				<pre><code>&lt;div ng-app="" ng-init="value = [1,2,3,4,5,6,7,8,9]; limit = 9"&gt;
	&lt;div&gt;
		&lt;strong&gt;Limit To: &lt;/strong&gt;
		&lt;input ng-model="limit"/&gt;
		&lt;em&gt; {{value | limitTo:limit}}&lt;/em&gt;
	&lt;/div&gt;
&lt;/div></code></pre>
				<iframe src="examples/filters2.html"></iframe>

				<aside class="notes">
					Filters can also take parameters and be used to transform arrays, like so.<br/>
					<em>Demo</em><br/>
					One thing you do need to be aware of is that your filter will rerun every time the $digest loop runs, so you want to keep your filters fast and efficient.
				</aside>
			</section>

			<section>
				<h2>Filters</h2>
				<p>Filters are defined as a function which returns (or provides) the filter function that gets run</p>
				<pre><code>&lt;div ng-app="MyApp" ng-init="value = 'My Value'"&gt;
	&lt;div&gt;
		&lt;strong&gt;value: &lt;/strong&gt;
		&lt;input ng-model="value"/&gt;
		&lt;em&gt; {{value | ni:' BATANG!'}}&lt;/em&gt;
	&lt;/div&gt;
&lt;/div&gt;
&lt;script type="text/javascript"&gt;
	angular.module('MyApp', []).filter('ni', function () {
		return function (input, suffix) {
			return input + ' NI!' + suffix;
		};
	});
&lt;/script&gt;</code></pre>
				<iframe src="examples/filters3.html"></iframe>

				<aside class="notes">
					When you create a filter you create a function, with whatever dependency injection is required, that returns a function, which is then run with the input as the first parameter.
				</aside>
			</section>

			<section>
				<h2>Filters</h2>
				<p>They can also be chained together</p>
				<pre><code>&lt;div ng-app="MyApp" ng-init="value = 'My Value'"&gt;
	&lt;div&gt;
		&lt;strong&gt;value: &lt;/strong&gt;
		&lt;input ng-model="value"/&gt;
		&lt;em&gt; {{value | uppercase | ni:' BATANG!'}}&lt;/em&gt;
	&lt;/div&gt;
&lt;/div&gt;</code></pre>
				<iframe src="examples/filters4.html"></iframe>

				<aside class="notes">
					Filters can also be chained together
				</aside>
			</section>
		</section>

	<section id="services">
		<section>
			<h2>Services</h2>
			<p>Services are singleton objects that you can inject into other Angular components</p>
			<pre><code>&lt;div ng-app="MyApp" ng-controller="MyCtrl"&gt;
	&lt;div&gt;
		&lt;strong&gt;myService.myValue: &lt;/strong&gt;
		&lt;input ng-model="myService.myValue"/&gt;
		&lt;em&gt; {{myService.myValue}}&lt;/em&gt;
	&lt;/div&gt;
	&lt;button ng-click="myMethod('myValue')"&gt;reset&lt;/button&gt;
&lt;/div&gt;
&lt;script type="text/javascript"&gt;
	angular.module('MyApp', []).factory('myService', function () {
		return {
			myValue: 'Service value'
		};
	});
function MyCtrl($scope, myService) {
	$scope.myService = myService;
}
&lt;/script&gt;&lt;/code></pre>
			<iframe src="examples/services.html"></iframe>

			<aside class="notes">
				There's really not much that can be said about 'services' as components.<br/>
				They're singletons, meaning there's only ever one instance, unlike controllers which may run on different scopes.<br/>
				And they can be injected into other components: controllers, filters, directives, and other services.<br/>
				Being singletons, services are the best choice for handling cross-controller communication, and as a way to pass around your data model.
			</aside>
		</section>
	</section>

	</div>

</div>
<script type="text/javascript" src="../lib/reveal/lib/js/head.min.js"></script>
<script type="text/javascript" src="../lib/reveal/js/reveal.min.js"></script>
<script type="text/javascript" src="../js/presentationInit.js"></script>
</body>
</html>